/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : Carte_microSD.c
**     Project     : cartesd_temperature_gsm_ok01
**     Processor   : MK64FN1M0VLQ12
**     Component   : SD_Card
**     Version     : Component 01.178, Driver 01.00, CPU db: 3.00.000
**     Repository  : My Components
**     Compiler    : GNU C Compiler
**     Date/Time   : 2018-02-01, 13:43, # CodeGen: 15
**     Abstract    :
**         Implements interface to SD card for FatFs
**     Settings    :
**          Component name                                 : Carte_microSD
**          Block size                                     : 512
**          Cmd wait counter                               : 10
**          Wait Ready Timeout (ms)                        : 500
**          Wait Cmd Timeout (ms)                          : 100
**          Receive Block Timeout (ms)                     : 500
**          SPI Block Transfer                             : no
**          Hardware                                       : 
**            SW SPI                                       : Disabled
**            HW SPI                                       : Enabled
**              Slow Baud Rate Mode                        : 0
**              Fast Baud Rate Mode                        : 1
**              LDD HW SPI                                 : Enabled
**                LDD HW SPI                               : SM_micro_sd
**              non-LDD HW SPI                             : Disabled
**            SPI Read/Write Macros                        : Disabled
**            Slave Select                                 : Enabled
**              LDD SS                                     : Enabled
**                Slave Select Pin                         : LDDSS
**              non-LDD SS                                 : Disabled
**            Activate                                     : Disabled
**            Card detection                               : Enabled
**              Card Detect is LOW active                  : no
**              LDD CD                                     : Enabled
**                Card detection pin                       : LDDCDI
**              non-LDD CD                                 : Disabled
**            Report 'Card present' if no Card detection pin: yes
**            Write protection                             : Disabled
**          System                                         : 
**            Wait                                         : WAIT1
**            Timeout                                      : TMOUT1
**            RTOS                                         : Disabled
**     Contents    :
**         Init             - byte Carte_microSD_Init(void* unused);
**         Deinit           - byte Carte_microSD_Deinit(void* unused);
**         Activate         - void Carte_microSD_Activate(void);
**         Deactivate       - void Carte_microSD_Deactivate(void);
**         isWriteProtected - bool Carte_microSD_isWriteProtected(void);
**         CardPresent      - bool Carte_microSD_CardPresent(void);
**         WaitReady        - byte Carte_microSD_WaitReady(void);
**         ReceiveDataBlock - bool Carte_microSD_ReceiveDataBlock(byte *data, word nofBytes);
**         SendDataBlock    - bool Carte_microSD_SendDataBlock(byte *data, byte token, word nofBytes);
**         SendCmd          - byte Carte_microSD_SendCmd(byte cmd, dword arg);
**         SetSlowMode      - void Carte_microSD_SetSlowMode(void);
**         SetFastMode      - void Carte_microSD_SetFastMode(void);
**         InitCommChannel  - void Carte_microSD_InitCommChannel(void);
**
**     License   :  Open Source (LGPL)
**     Copyright : (c) Copyright Erich Styger, 2012-2015, all rights reserved.
**     Web       : www.mcuoneclipse.com
**     This an open source software implementing an SD card low level driver useful for the the ChaN FatFS, using Processor Expert.
**     This is a free software and is opened for education,  research and commercial developments under license policy of following terms:
**     * This is a free software and there is NO WARRANTY.
**     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
**     * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/
/*!
** @file Carte_microSD.c
** @version 01.00
** @brief
**         Implements interface to SD card for FatFs
*/         
/*!
**  @addtogroup Carte_microSD_module Carte_microSD module documentation
**  @{
*/         

/* MODULE Carte_microSD. */

#include "Carte_microSD.h"
#include "diskio.h"

static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
static uint8_t CardType = CT_SD1;       /* Card type flags */
static uint8_t speedMode = Carte_microSD_ACTIVATE_MODE_SLOW; /* current speed mode */

enum { /* SD card response codes */
  Carte_microSD_OK = 0,
  Carte_microSD_IDLE = 1
};

#define Carte_microSD_SPI_WRITE_BLOCK_ENABLED          0
#define Carte_microSD_SPI_WRITE_READ_BLOCK_ENABLED     0

/* different wait counters to deal with slow SD cards */
#define Carte_microSD_TIMEOUT_READY_MS       500 /* user configured wait timeout until the device is ready */
#define Carte_microSD_TIMEOUT_CMD_MS         100 /* user configured wait timeout for commands */
#define Carte_microSD_TIMEOUT_READ_BLOCK_MS  500 /* user configured wait timeout for reading a data block */
#define Carte_microSD_ENABLE_SS()   SS1_ClrVal(SS1_DeviceData) /* enable slave (low active) */
#define Carte_microSD_DISABLE_SS()  SS1_SetVal(SS1_DeviceData) /* disable slave (low active) */
#define Carte_microSD_DUMMY 0xff /* SPI dummy value */

/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS Carte_microSD_disk_initialize (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  uint8_t n, cmd, ty, ocr[4];

  (void)drv; /* not used */
  if (Stat&STA_NODISK) {
    return Stat;                        /* No card in the socket */
  }
  if (Carte_microSD_Init(NULL) != ERR_OK) {
    return STA_NOINIT;
  }
  ty = 0;
  if (Carte_microSD_SendCmd(Carte_microSD_CMD0, 0) == 1) { /* Enter Idle state */
    if (Carte_microSD_SendCmd(Carte_microSD_CMD8, 0x1AA) == 1) { /* SDHC */
      for (n = 0; n < 4; n++) {
        ocr[n] = Carte_microSD_ReceiveByte(); /* Get trailing return value of R7 resp */
      }
      if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
        while (Carte_microSD_SendCmd(Carte_microSD_ACMD41, 1UL << 30)) {
          /* Wait for leaving idle state (ACMD41 with HCS bit) */
        }
        if (Carte_microSD_SendCmd(Carte_microSD_CMD58, 0) == 0) { /* Check CCS bit in the OCR */
          for (n = 0; n < 4; n++) {
            ocr[n] = Carte_microSD_ReceiveByte();
          }
          ty = (uint8_t)((ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2); /* SDv2 */
        }
      }
    } else {                            /* SDSC or MMC */
      if (Carte_microSD_SendCmd(Carte_microSD_ACMD41, 0) <= 1) {
        ty = CT_SD1; cmd = Carte_microSD_ACMD41; /* SDv1 */
      } else {
        ty = CT_MMC; cmd = Carte_microSD_CMD1; /* MMCv3 */
      }
      while (Carte_microSD_SendCmd(cmd, 0)) {
        /* Wait for leaving idle state */
      }
      if (Carte_microSD_SendCmd(Carte_microSD_CMD16, Carte_microSD_BLOCK_SIZE) != 0) { /* Set R/W block length  */
        ty = 0;
      }
    }
    Carte_microSD_SetFastMode();
  }
  CardType = ty;
  Stat &= ~STA_NOINIT;                  /* Clear STA_NOINIT */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS Carte_microSD_disk_status (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  (void)drv; /* not used */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT Carte_microSD_disk_read (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t *buff,                  /* Data buffer to store read data */
        uint32_t sector,                /* Sector address (LBA) */
        unsigned int count              /* Number of sectors to read (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= Carte_microSD_BLOCK_SIZE; /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block read */
    if (   (Carte_microSD_SendCmd(Carte_microSD_CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
        && Carte_microSD_ReceiveDataBlock(buff, Carte_microSD_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block read */
    if (Carte_microSD_SendCmd(Carte_microSD_CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
      do {
        if (!Carte_microSD_ReceiveDataBlock(buff, Carte_microSD_BLOCK_SIZE)) {
          break;
        }
        buff += Carte_microSD_BLOCK_SIZE;
      } while (--count);
      (void)Carte_microSD_SendCmd(Carte_microSD_CMD12, 0); /* STOP_TRANSMISSION */
    }
  }
  return count ? RES_ERROR : RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT Carte_microSD_disk_write (
        uint8_t drv,                    /* Physical drive number (0..) */
        const uint8_t *buff,            /* Data to be written */
        uint32_t sector,                /* Sector address (LBA) */
        unsigned int count              /* Number of sectors to write (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (Stat & STA_PROTECT) {
    return RES_WRPRT;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= Carte_microSD_BLOCK_SIZE; /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block write */
    if (  (Carte_microSD_SendCmd(Carte_microSD_CMD24, sector) == 0) /* WRITE_BLOCK */
        && Carte_microSD_SendDataBlock((byte*)buff, 0xFE, Carte_microSD_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block write */
    if (CardType & CT_SDC) {
      (void)Carte_microSD_SendCmd(Carte_microSD_ACMD23, count);
    }
    if (Carte_microSD_SendCmd(Carte_microSD_CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
      do {
        if (!Carte_microSD_SendDataBlock((byte*)buff, 0xFC, Carte_microSD_BLOCK_SIZE)) {
          break;
        }
        buff += Carte_microSD_BLOCK_SIZE;
      } while (--count);
      if (!Carte_microSD_SendDataBlock(0, 0xFD, Carte_microSD_BLOCK_SIZE)) { /* STOP_TRAN token */
        count = 1;
      }
    }
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static bool chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT Carte_microSD_disk_ioctl (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t ctrl,                   /* Control code */
        void *buff                      /* Buffer to send/receive control data */
)
{
  DRESULT res = RES_OK;
  uint8_t n, csd[16], *ptr = (uint8_t*)buff;
  uint16_t csize;

  (void)drv; /* not used */
  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                           /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
        /*lint -save -e522 Highest operation lacks side effect */
          power_off();                  /* Power off */
        /*lint -restore */
        }
        break;
      case 1:                           /* Sub control code == 1 (POWER_ON) */
        /*lint -save -e522 Highest operation lacks side effect */
        power_on();                     /* Power on */
        /*lint -restore */
        break;
      case 2:                           /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                  /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        if (Carte_microSD_WaitReady() != ERR_OK) {
          res = RES_ERROR;
        }
        break;
      case MMC_GET_READ_BL_LEN:         /* get Block Length */
        if ((Carte_microSD_SendCmd(Carte_microSD_CMD9, 0) == 0) && Carte_microSD_ReceiveDataBlock(csd, 16)) {
          switch((csd[5]&15)) {         /* READ_BL_LEN is either 9, 10 or 11, end the block size is 2^READ_BL_LEN */
            case 9: *(uint16_t*)ptr = 512; break;
            case 10: *(uint16_t*)ptr = 1024; break;
            case 11: *(uint16_t*)ptr = 2048; break;
            default: *(uint16_t*)ptr = 0; break; /* illegal */
          }
        }
        break;
      case MMC_GET_SDC_VERSION:         /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        if ((Carte_microSD_SendCmd(Carte_microSD_CMD9, 0) == 0) && Carte_microSD_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            *ptr = 2;
          } else {                      /* SDC ver 1.XX or MMC*/
            *ptr = 1;
          }
        }
        break;
      case GET_SECTOR_COUNT :           /* Get number of sectors on the disk (uint32_t) */
        if ((Carte_microSD_SendCmd(Carte_microSD_CMD9, 0) == 0) && Carte_microSD_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            csize = (uint16_t)(csd[9] + ((uint16_t)csd[8] << 8) + 1);
            *(uint32_t*)buff = (uint32_t)csize << 10;
          } else {                      /* SDC ver 1.XX or MMC*/
            n = (uint8_t)((csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2);
            csize = (uint16_t)((csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1);
            *(uint32_t*)buff = (uint32_t)csize << (byte)(n - 9);
          }
        }
        break;
      case GET_SECTOR_SIZE :            /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = Carte_microSD_BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE :             /* Get erase block size in unit of sector (uint32_t) */
        if (CardType & CT_SD2) {        /* SDC ver 2.00 */
          if (Carte_microSD_SendCmd(Carte_microSD_ACMD13, 0) == 0) { /* Read SD status */
            (void)Carte_microSD_ReceiveByte();
            if (Carte_microSD_ReceiveDataBlock(csd, 16)) { /* Read partial block */
              for (n = 64 - 16; n; n--) {
                (void)Carte_microSD_ReceiveByte(); /* Purge trailing data */
              }
              *(uint32_t*)buff = 16UL << (csd[10] >> 4);
            }
          }
        } else {                        /* SDC ver 1.XX or MMC */
          if ((Carte_microSD_SendCmd(Carte_microSD_CMD9, 0) == 0) && Carte_microSD_ReceiveDataBlock(csd, 16)) {        /* Read CSD */
            if (CardType & CT_SD1) {    /* SDC ver 1.XX */
              *(uint32_t*)buff = (uint32_t)((((csd[10] & 63) << 1) + ((uint16_t)(csd[11] & 128) >> 7) + 1) << (byte)((csd[13] >> 6) - 1));
            } else {                    /* MMC */
              *(uint32_t*)buff = (uint32_t)(((uint16_t)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1));
            }
          }
        }
        break;
      case MMC_GET_TYPE :               /* Get card type flags (1 byte) */
        *ptr = CardType;
        break;

      case MMC_GET_CSD :                /* Receive CSD as a data block (16 bytes) */
         if (!(Carte_microSD_SendCmd(Carte_microSD_CMD9, 0) == 0 /* READ_CSD */
            && Carte_microSD_ReceiveDataBlock(ptr, 16)))
         {
           res = RES_PARERR;
         }
         break;
      case MMC_GET_CID :                /* Receive CID as a data block (16 bytes) */
        if (!(Carte_microSD_SendCmd(Carte_microSD_CMD10, 0) == 0 /* READ_CID */
            && Carte_microSD_ReceiveDataBlock(ptr, 16)))
        {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_OCR :                /* Receive OCR as an R3 resp (4 bytes) */
        if (Carte_microSD_SendCmd(Carte_microSD_CMD58, 0) == 0) { /* READ_OCR */
          for (n = 4; n; n--) {
            *ptr++ = Carte_microSD_ReceiveByte();
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_SDSTAT :             /* Receive SD status as a data block (64 bytes) */
        if (Carte_microSD_SendCmd(Carte_microSD_ACMD13, 0) == 0) { /* SD_STATUS */
          (void)Carte_microSD_ReceiveByte();
          if (!Carte_microSD_ReceiveDataBlock(ptr, 64)) {
            res = RES_PARERR;
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_DRIVER_VERSION:      /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 0;
        break;

      default:
        res = RES_PARERR;
    } /* switch */
  } /* if-else */
  return res;
}

#define Carte_microSD_SPI_Enable()                   (void)SM_micro_sd_Enable(SM_micro_sd_DeviceData)
#define Carte_microSD_SPI_Disable()                  (void)SM_micro_sd_Disable(SM_micro_sd_DeviceData)
#define Carte_microSD_SPI_SetSlowMode()              (void)SM_micro_sd_SelectConfiguration(SM_micro_sd_DeviceData, 0, 0) /* max 400kbps */
#define Carte_microSD_SPI_SetFastMode()              (void)SM_micro_sd_SelectConfiguration(SM_micro_sd_DeviceData, 1, 1) /* max 12Mbps */
#define Carte_microSD_SPI_SetShiftClockPolarity(val) /* not needed for LDD */
#define Carte_microSD_SPI_SetIdleClockPolarity(val)  /* not needed for LDD */

static volatile bool Carte_microSD_DataReceivedFlag = FALSE;

void Carte_microSD_SPI_WRITE(unsigned char write) {
  unsigned char dummy;

  Carte_microSD_DataReceivedFlag = FALSE;
  (void)SM_micro_sd_ReceiveBlock(SM_micro_sd_DeviceData, &dummy, sizeof(dummy));
  (void)SM_micro_sd_SendBlock(SM_micro_sd_DeviceData, &write, sizeof(write));
  while(!Carte_microSD_DataReceivedFlag){}
}

#if Carte_microSD_SPI_WRITE_BLOCK_ENABLED
static void Carte_microSD_SPI_WRITE_BLOCK(unsigned char *writeP, uint16_t size) {
  unsigned char dummy[4];
  uint16_t writeSize;

  while(size>0) {
    if (size>sizeof(dummy)) {
      writeSize = sizeof(dummy);
    } else {
      writeSize = size;
    }
    Carte_microSD_DataReceivedFlag = FALSE;
    (void)SM_micro_sd_ReceiveBlock(SM_micro_sd_DeviceData, &dummy[0], writeSize);
    (void)SM_micro_sd_SendBlock(SM_micro_sd_DeviceData, writeP, writeSize);
    while(!Carte_microSD_DataReceivedFlag){}
    size -= writeSize;
    writeP += writeSize;
  }
}
#endif /* Carte_microSD_SPI_WRITE_BLOCK_ENABLED */

static void Carte_microSD_SPI_WRITE_READ(unsigned char write, unsigned char *readP) {
  Carte_microSD_DataReceivedFlag = FALSE;
  (void)SM_micro_sd_ReceiveBlock(SM_micro_sd_DeviceData, readP, 1);
  (void)SM_micro_sd_SendBlock(SM_micro_sd_DeviceData, &write, 1);
  while(!Carte_microSD_DataReceivedFlag){}
}

#if Carte_microSD_SPI_WRITE_READ_BLOCK_ENABLED
static void Carte_microSD_SPI_WRITE_READ_BLOCK(unsigned char *writeP, unsigned char *readP, uint16_t size) {
  Carte_microSD_DataReceivedFlag = FALSE;
  (void)SM_micro_sd_ReceiveBlock(SM_micro_sd_DeviceData, readP, size);
  (void)SM_micro_sd_SendBlock(SM_micro_sd_DeviceData, writeP, size);
  while(!Carte_microSD_DataReceivedFlag){}
}
#endif /* Carte_microSD_SPI_WRITE_READ_BLOCK_ENABLED */


#if Carte_microSD_SPI_WRITE_BLOCK_ENABLED || Carte_microSD_SPI_WRITE_READ_BLOCK_ENABLED
#define SPI_WRITE_READ_BLOCK_SIZE_DUMMY 512 /* 512 bytes of dummy values */
static const uint8_t dummyArr[SPI_WRITE_READ_BLOCK_SIZE_DUMMY] = {
  Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY,
  Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY,
  Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY,
  Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY,
  Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY,
  Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY, Carte_microSD_DUMMY
};
#endif

/* Internal method prototypes */
static byte SendCommand(byte cmd, byte *arg, byte response);

/*
** ===================================================================
**     Method      :  Carte_microSD_Activate (component SD_Card)
**     Description :
**         If multiple devices are used on the same SPI bus, then the
**         device needs to be activated. That way, the different SPI
**         protocol is selected.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void Carte_microSD_Activate(void)
{
  /* Note that the SD card SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
   * typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  Carte_microSD_InitCommChannel();
  Carte_microSD_ENABLE_SS();            /* select slave */
}

/*
** ===================================================================
**     Method      :  Carte_microSD_Deactivate (component SD_Card)
**     Description :
**         Removes/deactivates the card from the bus
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void Carte_microSD_Deactivate(void)
{
  Carte_microSD_DISABLE_SS();           /* de-select slave */
}

/*
** ===================================================================
**     Method      :  Carte_microSD_WaitReady (component SD_Card)
**     Description :
**         Wait until the card is ready
**     Parameters  : None
**     Returns     :
**         ---             - Error code
**                           ERR_OK: device is ready
**                           ERR_BUSY: device is still busy
** ===================================================================
*/
byte Carte_microSD_WaitReady(void)
{
  byte tmp;
  TMOUT1_CounterHandle timeout;

  Carte_microSD_Activate();
  Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY);
  timeout = TMOUT1_GetCounter(Carte_microSD_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* set up timeout counter */
  for (;;) {                            /* will timeout */
    Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &tmp); /* write dummy value, read status */
    if (tmp==0xff) {
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  } /* for */
  TMOUT1_LeaveCounter(timeout);
  Carte_microSD_Deactivate();
  if (tmp==0xff) {
    return ERR_OK; /* device is ready */
  } else {
    return ERR_BUSY;
  }
}

/*
** ===================================================================
**     Method      :  Carte_microSD_ReceiveDataBlock (component SD_Card)
**     Description :
**         Retrieve a data block from the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data buffer
**         nofBytes        - number of bytes to retrieve,
**                           must be a multiple of 4
**     Returns     :
**         ---             - TRUE if reading was going fine, FALSE
**                           otherwise.
** ===================================================================
*/
bool Carte_microSD_ReceiveDataBlock(byte *data, word nofBytes)
{
  byte tmp;
  TMOUT1_CounterHandle timeout;
  word cnt = 512; /* polling counter */

  Carte_microSD_Activate();
  /* poll response */
  do {
    Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &tmp); /* send dummy value, poll response */
    cnt--;
  } while (tmp==0xFF && cnt>0);
  if (tmp==0xFF) { /* polling not successful, now poll for a longer period of time */
    timeout = TMOUT1_GetCounter(Carte_microSD_TIMEOUT_READ_BLOCK_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
    for (;;) {                          /* will timeout */
      Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &tmp); /* send dummy value, poll response */
      if (tmp!=0xFF) {
        break;
      }
      if (TMOUT1_CounterExpired(timeout)) {
        break;
      }
    } /* for */
    TMOUT1_LeaveCounter(timeout);
  } /* if */
  if (tmp != 0xFE) {                    /* if it is not expected response, return with error */
    Carte_microSD_Deactivate();
    return FALSE;
  }
  /*lint -save -e539 Did not expect positive indentation  */
#if Carte_microSD_SPI_WRITE_READ_BLOCK_ENABLED
  if (nofBytes<=SPI_WRITE_READ_BLOCK_SIZE_DUMMY) {
    Carte_microSD_SPI_WRITE_READ_BLOCK((unsigned char*)&dummyArr[0], data, nofBytes); /* write dummy value, read data */
  } else {
#endif
    while(nofBytes>0) {
      Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, data); /* write dummy value, read data */
      data++;
      nofBytes--;
    }
#if Carte_microSD_SPI_WRITE_READ_BLOCK_ENABLED
  }
#endif
  /*lint -restore Did not expect positive indentation */
  Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY); /* checksum Bytes not needed */
  Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY);
  Carte_microSD_Deactivate();
  return TRUE;
}

/*
** ===================================================================
**     Method      :  Carte_microSD_SendDataBlock (component SD_Card)
**     Description :
**         Send a data block to the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data blocks with 512 bytes
**                           each
**         token           - data/stop token
**         nofBytes        - Number of bytes to send
**     Returns     :
**         ---             - Returns TRUE for success, FALSE for
**                           failure.
** ===================================================================
*/
bool Carte_microSD_SendDataBlock(byte *data, byte token, word nofBytes)
{
  byte resp;

  if (Carte_microSD_WaitReady()!=ERR_OK) {
    return FALSE;                       /* device not ready */
  }
  Carte_microSD_Activate();
  Carte_microSD_SPI_WRITE(token);       /* Xmit data token */
  if (token != 0xFD) {                  /* Is data token, not STOP_TRAN */
#if Carte_microSD_SPI_WRITE_BLOCK_ENABLED
    Carte_microSD_SPI_WRITE_BLOCK(data, nofBytes);
#else
    while (nofBytes!=0) {               /* send the bytes */
      Carte_microSD_SPI_WRITE(*data);
      data++;
      nofBytes--;
    }
#endif
    Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY); /* CRC (Dummy) */
    Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY); /* CRC (Dummy) */
    Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &resp); /* write dummy value, receive data response */
    if ((resp&0x1F) != 0x05) {          /* If not accepted, return with error */
      Carte_microSD_Deactivate();
      return FALSE;
    }
    /* if we do not poll the device for its busy state, we need to provide at least 8 clocks (dummy cycle).
     * See http://elm-chan.org/docs/mmc/mmc_e.html:
     *    In principle of the SPI mode, the CS signal must be asserted during a transaction,
     *    however there is an exception to this rule. When the card is busy, the host controller
     *    can deassert CS to release SPI bus for any other SPI devices. The card will drive DO signal
     *    low again when reselect it during internal process is in progress.
     *    Therefore a preceding busy check (wait ready immediately before command and data packet)
     *    instead of post wait can eliminate waste wait time. In addition the internal process is initiated
     *    a byte after the data response, this means eight clocks are required to initiate internal write operation.
     */
    Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY);
  }
  Carte_microSD_Deactivate();
  return TRUE;
}

/*
** ===================================================================
**     Method      :  Carte_microSD_SendCmd (component SD_Card)
**     Description :
**         Sends a command to the device and returns the response
**     Parameters  :
**         NAME            - DESCRIPTION
**         cmd             - Command to send
**         arg             - command argument
**     Returns     :
**         ---             - device response
** ===================================================================
*/
byte Carte_microSD_SendCmd(byte cmd, dword arg)
{
  byte n, res;
  TMOUT1_CounterHandle timeout;

  if (cmd&0x80) {                       /* ACMD<n> is the command sequence of CMD55-CMD<n> */
    cmd &= 0x7F;
    res = Carte_microSD_SendCmd(Carte_microSD_CMD55, 0);
    if (res > 1) {
      return res;
    }
  }
  /* Select the card and wait for ready */
  if (Carte_microSD_WaitReady() != ERR_OK) {
    return 0xFF;
  }
  Carte_microSD_Activate();
  /* Send command packet */
  Carte_microSD_SPI_WRITE(cmd);         /* Start + Command index */
  n = (byte)(arg>>24);
  Carte_microSD_SPI_WRITE(n);           /* Argument[31..24] */
  n = (byte)(arg>>16);
  Carte_microSD_SPI_WRITE(n);           /* Argument[23..16] */
  n = (byte)(arg>>8);
  Carte_microSD_SPI_WRITE(n);           /* Argument[15..8] */
  Carte_microSD_SPI_WRITE((byte)arg);   /* Argument[7..0] */
  if (cmd == Carte_microSD_CMD0) {
    n = 0x95;                           /* Valid CRC for CMD0(0) */
  } else if (cmd == Carte_microSD_CMD8) {
    n = 0x87;                           /* Valid CRC for CMD8(0x1AA) */
  } else {
    n = 0x01;                           /* Dummy CRC + Stop */
  }
  Carte_microSD_SPI_WRITE(n);
  /* Receive command response */
  if (cmd == Carte_microSD_CMD12) {
    Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &res); /* send dummy value, poll response */
  }
  timeout = TMOUT1_GetCounter(Carte_microSD_TIMEOUT_CMD_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  for(;;) {                            /* will timeout */
    Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &res); /* send dummy value, poll response */
    if (!(res&0x80)) {                 /* valid response */
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  }
  TMOUT1_LeaveCounter(timeout);
  Carte_microSD_Deactivate();
  return res;                           /* Return with the response value */
}
/*
** ===================================================================
**     Method      :  Carte_microSD_isWriteProtected (component SD_Card)
**     Description :
**         Determines if the card is write protected. Note that this is
**         an indicator only, as it is still possible to write to the
**         card even if the write protection is set on the card!
**     Parameters  : None
**     Returns     :
**         ---             - True if the card has the write protection
**                           set, false otherwise
** ===================================================================
*/
/*
bool Carte_microSD_isWriteProtected(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  SendCommand (component SD_Card)
**
**     Description :
**         Sends a command to the SD card
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte SendCommand(byte cmd, byte *arg, byte response)
{
  #define NOF_WAIT_ITERATIONS 3
  byte u8Temp=0;
  byte u8Counter;

  Carte_microSD_Activate();
  Carte_microSD_SPI_WRITE(cmd);         /* Send Start byte */
  /* Send Argument */
  for(u8Counter=0; u8Counter<4; u8Counter++) {
    Carte_microSD_SPI_WRITE(arg[u8Counter]);
  }
  Carte_microSD_SPI_WRITE(0x95);        /* Send CRC */
  /* Response Handler */
  for (u8Counter=0;u8Counter<NOF_WAIT_ITERATIONS;u8Counter++) {
    Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &u8Temp); /* send dummy value, poll response */
    if (u8Temp==response) {
      break;
    }
  } /* for */
  Carte_microSD_Deactivate();
  if (u8Temp==response) {
    return ERR_OK;
  } else {
    return ERR_FAULT;
  }
}

/*
** ===================================================================
**     Method      :  Carte_microSD_Init (component SD_Card)
**     Description :
**         Initializes the driver
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - unused parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte Carte_microSD_Init(void* unused)
{
  /* The behavior of SD cards in SPI mode is basically the same as for any SPI slave device.
     The maximum transfer rate of the SD card in SPI mode is 25 Mbps, but in the initialization process the
     transfer rate must be less than 375 kbps. This is because the SPI mode of the SD cards is compatible with
     the MMC cards, and MMC cards can only reach 375 kbps. After initialization, the SPI clock can be
     changed to 25 Mbps.
     Note that the SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
     typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  dword arg;
  TMOUT1_CounterHandle timeout;
  bool isTimeout = FALSE;
  byte cnt;

  (void)unused;
  /* -------------------------------- Init & Slow Mode -------------------------------- */
  /* after voltage reaches 2.2V, need to wait at least 1 ms. Then we need to set Data and CS/Chipselect high for at least 74 clocks */
  /*lint -save -e522 function lacks side-effects */
  WAIT1_Waitms(1);                      /* wait at least for 1 ms on insertion and power on */
  /*lint -restore */
  speedMode = Carte_microSD_ACTIVATE_MODE_SLOW;
  Carte_microSD_Activate();             /* select slave */
  Carte_microSD_SetSlowMode();          /* set the SPI clock to 375 kbps. This is required for compatibility across a wide range of SD and MMC cards. */
  Carte_microSD_DISABLE_SS();           /* disable slave (CS high) */
  for(cnt=0;cnt<10;cnt++) {             /* send at least 75 SPI clock cycles with the SS signal asserted to ensure that the SD card internal state machine is initialized. */
    Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY);
  }
  /*lint -save -e522 function lacks side-effects */
  WAIT1_Waitus(50);                     /* need to wait a little bin in order SPI transfer to be finished (need this on CN128, but on others too?) */
  /*lint -restore */
  Carte_microSD_Deactivate();
  /* -------------------------------- IDLE Command -------------------------------- */
  arg = 0;
  timeout = TMOUT1_GetCounter(Carte_microSD_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  while (SendCommand(Carte_microSD_CMD0, (byte*)&arg, Carte_microSD_IDLE) != ERR_OK) {
    if (TMOUT1_CounterExpired(timeout)) {
      isTimeout = TRUE;                /* indicate a timeout */
      break;
    }
  } /* while */
  TMOUT1_LeaveCounter(timeout);
  if (isTimeout) {                      /* timeout */
    return ERR_FAULT;
  }
  /* Send 8 SPI clocks (SS unasserted). */
  Carte_microSD_Activate();
  Carte_microSD_DISABLE_SS();           /* disable slave */
  Carte_microSD_SPI_WRITE(Carte_microSD_DUMMY); /* dummy SPI cycle */
  Carte_microSD_Deactivate();           /* de-select slave */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  Carte_microSD_ReceiveByte (component SD_Card)
**
**     Description :
**         Receives a byte from the SPI bus
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte Carte_microSD_ReceiveByte(void)
{
  byte data;

  Carte_microSD_Activate();
  Carte_microSD_SPI_WRITE_READ(Carte_microSD_DUMMY, &data); /* send dummy value, poll response */
  Carte_microSD_Deactivate();
  return data;
}

/*
** ===================================================================
**     Method      :  Carte_microSD_CardPresent (component SD_Card)
**     Description :
**         Returns true in case a card is present. If there is no card
**         detection pin, then this routine will always return true.
**     Parameters  : None
**     Returns     :
**         ---             - Returns true if card is present, false
**                           otherwise.
** ===================================================================
*/
/*
bool Carte_microSD_CardPresent(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  Carte_microSD_SetSlowMode (component SD_Card)
**     Description :
**         Switches to slow mode SPI communication speed.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void Carte_microSD_SetSlowMode(void)
{
#if 0 /* if using LDD component, do not disable the SPI, as Carte_microSD_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
  Carte_microSD_SPI_Disable();
#endif
  Carte_microSD_SPI_SetSlowMode();      /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
  speedMode = Carte_microSD_ACTIVATE_MODE_SLOW;
#if 0 /* if using LDD component, do not disable the SPI, as Carte_microSD_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
  Carte_microSD_SPI_Enable();
#endif
}

/*
** ===================================================================
**     Method      :  Carte_microSD_SetFastMode (component SD_Card)
**     Description :
**         Switches to fast mode SPI communication speed.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void Carte_microSD_SetFastMode(void)
{
#if 0 /* if using LDD component, do not disable the SPI, as Carte_microSD_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
  Carte_microSD_SPI_Disable();
#endif
  Carte_microSD_SPI_SetFastMode();      /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
  speedMode = Carte_microSD_ACTIVATE_MODE_FAST;
#if 0 /* if using LDD component, do not disable the SPI, as Carte_microSD_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
  Carte_microSD_SPI_Enable();
#endif
}

/*
** ===================================================================
**     Method      :  Carte_microSD_InitCommChannel (component SD_Card)
**     Description :
**         Method to initialize the communication channel. This is
**         needed if the bus to the SD card is shared with other
**         devices.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void Carte_microSD_InitCommChannel(void)
{
  /* Settings:
    - 100-400 kHz clock during init, then max 12 MHz
    - Send MSB first
    - Shift clock idle polarity: low
    - Clock edge: falling edge
  */
  if (speedMode==Carte_microSD_ACTIVATE_MODE_FAST) {
    Carte_microSD_SetFastMode(); /* use fast mode. */
  } else {
    Carte_microSD_SetSlowMode(); /* use slow mode. */
  }
}

/*
** ===================================================================
**     Method      :  Carte_microSD_Deinit (component SD_Card)
**     Description :
**         Driver deinitialization routine.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - dummy parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte Carte_microSD_Deinit(void* unused)
{
  (void)unused;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  Carte_microSD_OnBlockReceived (component SD_Card)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SM_micro_sd_OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  /* Calling inherited event */
  (void)UserDataPtr; /* unused */
  Carte_microSD_DataReceivedFlag=TRUE;
}

/* END Carte_microSD. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
